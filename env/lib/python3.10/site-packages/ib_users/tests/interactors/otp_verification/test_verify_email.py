import pytest
from mock import create_autospec

from ib_users.constants.otp_verification_constants import OTPStatus, \
    OTP_EXPIRY_TIME_IN_SEC
from ib_users.exceptions.otp_verification_exceptions import ExceptionMessage, \
    InvalidEmailException, EmailIsBlackListedException
from ib_users.interactors.base_otp_verification_interactor import \
    BaseOTPVerificationInteractor
from ib_users.interactors.email_otp_verification_interactor import \
    EmailOTPVerificationInteractor
from ib_users.interactors.storages.otp_blacklist_storage import \
    OTPBlacklistStorage
from ib_users.interactors.third_party.email_sender import EmailSender
from ib_users.constants.otp_verification_constants import VerificationType
from ib_users.interactors.storages.otp_verification_storage import \
    GetOTPDetailsDTO
from ib_users.validators.email_validator import EmailValidator


class TestVerifyEmail:

    @ pytest.fixture
    def setup(self):
        from ib_users.interactors.storages.otp_verification_storage import \
            OTPVerificationStorage
        email = "sample@gmail.com"

        otp_verification_storage_mock = create_autospec(OTPVerificationStorage)
        otp_blacklist_storage_mock = create_autospec(OTPBlacklistStorage)
        email_sender_mock = create_autospec(EmailSender)
        generate_otp_value = "123456"

        def generate_otp_mock():
            return generate_otp_value

        BaseOTPVerificationInteractor._generate_otp = generate_otp_mock
        return otp_verification_storage_mock, email_sender_mock, email, \
               otp_blacklist_storage_mock

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_EMAIL_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    def test_verify_email(self, setup,
                          verification_type_mock: VerificationType):
        otp_status = OTPStatus.NOT_REQUESTED
        generate_otp_value = "123456"
        expiry_time_in_sec = OTP_EXPIRY_TIME_IN_SEC
        otp_verification_storage_mock, email_sender_mock, email, \
        otp_blacklist_storage_mock = setup

        email_otp_verification_interactor = EmailOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        otp_verification_storage_mock.get_otp_status_by_email.return_value \
            = OTPStatus.NOT_REQUESTED

        otp_blacklist_storage_mock.is_email_blacklisted.return_value = False
        otp_verification_storage_mock.is_email_whitelisted.return_value = False

        email_otp_verification_interactor.verify_email(
            email=email,
            email_validator=EmailValidator(),
            email_sender=email_sender_mock
        )
        otp_blacklist_storage_mock.is_email_blacklisted.\
            assert_called_once_with(email=email)

        otp_verification_storage_mock.get_otp_status_by_email.\
            assert_called_once_with(
                email=email, verification_type=verification_type_mock
        )

        if otp_status == OTPStatus.NOT_REQUESTED:
            otp_verification_storage_mock.create_otp_verification_for_email. \
                assert_called_once_with(
                    email=email,
                    otp=generate_otp_value,
                    expiry_time_in_sec=expiry_time_in_sec,
                    verification_type=verification_type_mock
                )
        else:
            otp_verification_storage_mock.update_otp_details. \
                assert_called_once_with(
                    email=email,
                    otp=generate_otp_value,
                    expiry_time_in_sec=expiry_time_in_sec,
                    verification_type=verification_type_mock
            )

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_EMAIL_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    def test_verify_email_when_prev_otp_is_not_expired(self, setup,
                                    verification_type_mock: VerificationType):

        otp_status = OTPStatus.ACTIVE
        previous_otp_value = "654321"
        expiry_time_in_sec = OTP_EXPIRY_TIME_IN_SEC
        otp_verification_storage_mock, email_sender_mock, email, \
        otp_blacklist_storage_mock = setup

        email_otp_verification_interactor = EmailOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        otp_blacklist_storage_mock.is_email_blacklisted.return_value \
            = False
        otp_verification_storage_mock.is_email_whitelisted.return_value = False
        otp_verification_storage_mock.get_otp_status_by_email.return_value = \
            otp_status
        otp_verification_storage_mock.get_otp_details_by_email.return_value = \
            GetOTPDetailsDTO(
                otp=previous_otp_value
            )

        email_otp_verification_interactor.verify_email(
            email=email,
            email_validator=EmailValidator(),
            email_sender=email_sender_mock
        )

        otp_blacklist_storage_mock.is_email_blacklisted. \
            assert_called_once_with(
                email=email
            )
        otp_verification_storage_mock.get_otp_details_by_email.\
            assert_called_once_with(
                email=email,
                verification_type=verification_type_mock
            )
        otp_verification_storage_mock.update_otp_details_by_email. \
            assert_called_once_with(
                email=email,
                otp=previous_otp_value,
                expiry_time_in_sec=expiry_time_in_sec,
                verification_type=verification_type_mock
            )
        email_sender_mock.send_otp.assert_called_once()

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_EMAIL_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    def test_verify_email_when_email_is_black_listed(self,setup,
                            verification_type_mock: VerificationType):
        otp_verification_storage_mock, email_sender_mock, email, \
        otp_blacklist_storage_mock = setup

        email_otp_verification_interactor = EmailOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        otp_blacklist_storage_mock.is_email_blacklisted.return_value \
            = True
        otp_verification_storage_mock.is_email_whitelisted.return_value = False

        with pytest.raises(EmailIsBlackListedException) as e:
            email_otp_verification_interactor.verify_email(
                email=email,
                email_validator=EmailValidator(),
                email_sender=email_sender_mock
            )

        otp_blacklist_storage_mock.is_email_blacklisted. \
            assert_called_once_with(
                email=email
            )

        assert ExceptionMessage.GIVEN_EMAIL_IS_BLACK_LISTED \
               in str(e.value)

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_UPDATE_PHONE_NUMBER_WITH_OTP,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    def test_verify_email_when_email_is_white_listed(self,
                                   setup,
                                   verification_type_mock: VerificationType):
        otp_verification_storage_mock, email_sender_mock, email, \
        otp_blacklist_storage_mock = setup

        otp = "123456"
        otp_status = OTPStatus.NOT_REQUESTED
        expiry_time_in_sec = OTP_EXPIRY_TIME_IN_SEC
        email_otp_verification_interactor = EmailOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )
        otp_blacklist_storage_mock.is_email_blacklisted. \
            return_value = False
        otp_verification_storage_mock.is_email_whitelisted. \
            return_value = True
        otp_verification_storage_mock.get_otp_status_by_email.\
            return_value = otp_status
        otp_verification_storage_mock.get_configured_otp_for_email.\
            return_value = GetOTPDetailsDTO(
                    otp=otp
            )

        email_otp_verification_interactor.verify_email(
            email=email,
            email_validator=EmailValidator(),
            email_sender=email_sender_mock
        )
        otp_verification_storage_mock.is_email_whitelisted. \
            assert_called_once_with(
               email=email
        )
        otp_verification_storage_mock.get_otp_status_by_email.\
            assert_called_once_with(
                email=email,
                verification_type=verification_type_mock
            )
        otp_verification_storage_mock.get_configured_otp_for_email. \
            assert_called_once_with(
                email=email
        )
        otp_verification_storage_mock.create_otp_verification_for_email.\
            assert_called_once_with(
                email=email,
                otp=otp,
                verification_type=verification_type_mock,
                expiry_time_in_sec=expiry_time_in_sec
            )
        email_sender_mock.send_otp.assert_called_once_with(
            email=email,
            otp=otp
        )

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_EMAIL_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    def test_verify_email_when_prev_otp_is_expired(self, setup,
                                    verification_type_mock: VerificationType):

        otp_status = OTPStatus.EXPIRED
        previous_otp_value = "123456"
        expiry_time_in_sec = OTP_EXPIRY_TIME_IN_SEC
        otp_verification_storage_mock, email_sender_mock, email, \
        otp_blacklist_storage_mock = setup

        email_otp_verification_interactor = EmailOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        otp_blacklist_storage_mock.is_email_blacklisted.return_value \
            = False
        otp_verification_storage_mock.is_email_whitelisted.return_value = False
        otp_verification_storage_mock.get_otp_status_by_email.return_value = \
            otp_status

        email_otp_verification_interactor.verify_email(
            email=email,
            email_validator=EmailValidator(),
            email_sender=email_sender_mock
        )

        otp_blacklist_storage_mock.is_email_blacklisted. \
            assert_called_once_with(
                email=email
            )
        otp_verification_storage_mock.update_otp_details_by_email.\
            assert_called_once_with(
                email=email,
                otp=previous_otp_value,
                expiry_time_in_sec=expiry_time_in_sec,
                verification_type=verification_type_mock
            )
        email_sender_mock.send_otp.assert_called_once()

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_EMAIL_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    def test_verify_email_when_email_is_invalid(self,setup,
                                verification_type_mock: VerificationType):
        otp_verification_storage_mock, email_sender_mock, email, \
        otp_blacklist_storage_mock = setup
        email = "hello@"
        email_validator_mock = create_autospec(EmailValidator)

        email_otp_verification_interactor = EmailOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        email_validator_mock.validate.side_effect = \
            InvalidEmailException(
                ExceptionMessage.ENTER_A_VALID_EMAIL
            )
        otp_blacklist_storage_mock.is_email_blacklisted.return_value \
            = False
        otp_verification_storage_mock.is_email_whitelisted.return_value = False

        with pytest.raises(InvalidEmailException) as e:
            email_otp_verification_interactor.verify_email(
                email=email,
                email_validator=email_validator_mock,
                email_sender=email_sender_mock
            )

        assert ExceptionMessage.ENTER_A_VALID_EMAIL in str(e.value)
