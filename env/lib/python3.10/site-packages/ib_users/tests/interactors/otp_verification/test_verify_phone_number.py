import pytest
from mock import create_autospec

from ib_users.constants.otp_verification_constants import OTPStatus, \
    OTP_EXPIRY_TIME_IN_SEC, SendOTPThrough
from ib_users.exceptions.otp_verification_exceptions import ExceptionMessage,\
    InvalidPhoneNumberException, PhoneNumberIsBlackListedException
from ib_users.interactors.phone_number_otp_verification_interactor import \
    BaseOTPVerificationInteractor, PhoneNumberOTPVerificationInteractor
from ib_users.interactors.third_party.call_service import CallService
from ib_users.interactors.third_party.phone_number_validator import \
    PhoneNumberValidator
from ib_users.interactors.third_party.sms_sender import SMSSender
from ib_users.interactors.storages.otp_verification_storage import \
    GetOTPDetailsDTO
from ib_users.utils.dtos import PhoneNumberDTO
from ib_users.constants.otp_verification_constants import VerificationType


class TestVerifyPhoneNumber:

    @ pytest.fixture
    def setup(self):
        from ib_users.interactors.storages.otp_verification_storage import \
            OTPVerificationStorage
        from ib_users.interactors.storages.otp_blacklist_storage import \
            OTPBlacklistStorage
        country_code = "+91"
        phone_number = "9866123399"
        phone_number_dto = PhoneNumberDTO(
            country_code=country_code,
            phone_number=phone_number
        )
        otp_verification_storage_mock = create_autospec(OTPVerificationStorage)
        otp_blacklist_storage_mock = create_autospec(OTPBlacklistStorage)
        sms_sender_mock = create_autospec(SMSSender)
        call_service_mock = create_autospec(CallService)
        phone_number_validator_mock = create_autospec(PhoneNumberValidator)

        generate_otp_value = "123456"

        def generate_otp_mock():
            return generate_otp_value

        BaseOTPVerificationInteractor._generate_otp = generate_otp_mock

        return phone_number_dto,  otp_blacklist_storage_mock, \
               otp_verification_storage_mock, sms_sender_mock, \
               call_service_mock, phone_number_validator_mock

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_UPDATE_PHONE_NUMBER_WITH_OTP,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value,
        VerificationType.VERIFY_UPDATE_PHONE_NUMBER_WITH_OTP,
    ])
    @pytest.mark.parametrize('send_otp_through', [
        SendOTPThrough.CALL,
        SendOTPThrough.SMS
    ])
    def test_verify_phone_number(self, setup,
                        verification_type_mock: VerificationType,
                        send_otp_through: SendOTPThrough):
        otp_status = OTPStatus.NOT_REQUESTED
        generate_otp_value = "123456"
        expiry_time_in_sec = OTP_EXPIRY_TIME_IN_SEC
        phone_number_dto,  otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, phone_number_validator_mock = setup

        phone_number_otp_verification_interactor = PhoneNumberOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        otp_blacklist_storage_mock.is_phone_number_blacklisted.\
            return_value = False
        otp_verification_storage_mock.is_phone_number_whitelisted.\
            return_value = False
        otp_verification_storage_mock.get_otp_status.return_value = otp_status

        phone_number_otp_verification_interactor.verify_phone_number(
            phone_number_dto=phone_number_dto,
            phone_number_validator=phone_number_validator_mock,
            send_otp_through=send_otp_through,
            sms_sender=sms_sender_mock,
            call_service=call_service_mock
        )

        otp_blacklist_storage_mock.is_phone_number_blacklisted.\
            assert_called_once_with(
                phone_number_dto=phone_number_dto
            )
        otp_verification_storage_mock.get_otp_status.\
            assert_called_once_with(
                phone_number_dto=phone_number_dto,
                verification_type=verification_type_mock
            )
        if otp_status == OTPStatus.NOT_REQUESTED:
            otp_verification_storage_mock.create_otp_verification. \
                assert_called_once_with(
                    phone_number_dto=phone_number_dto,
                    otp=generate_otp_value,
                    expiry_time_in_sec=expiry_time_in_sec,
                    verification_type=verification_type_mock
                )
        else:
            otp_verification_storage_mock.update_otp_details. \
                assert_called_once_with(
                    phone_number_dto=phone_number_dto,
                    otp=generate_otp_value,
                    expiry_time_in_sec=expiry_time_in_sec,
                    verification_type=verification_type_mock
            )
        if send_otp_through == SendOTPThrough.SMS:
            sms_sender_mock.send_otp.assert_called_once()
        elif send_otp_through == SendOTPThrough.CALL:
            call_service_mock.request_call.assert_called_once()

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_UPDATE_PHONE_NUMBER_WITH_OTP,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    @pytest.mark.parametrize('send_otp_through', [
        SendOTPThrough.CALL,
        SendOTPThrough.SMS
    ])
    def test_verify_phone_number_when_prev_otp_is_not_expired(self, setup,
                             verification_type_mock: VerificationType,
                             send_otp_through: SendOTPThrough):

        otp_status = OTPStatus.ACTIVE
        previous_otp_value = "654321"
        expiry_time_in_sec = OTP_EXPIRY_TIME_IN_SEC

        phone_number_dto,  otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, phone_number_validator_mock = setup

        phone_number_otp_verification_interactor = PhoneNumberOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        otp_blacklist_storage_mock.is_phone_number_blacklisted.return_value \
            = False
        otp_verification_storage_mock.is_phone_number_whitelisted.return_value = False
        otp_verification_storage_mock.get_otp_status.return_value = otp_status
        otp_verification_storage_mock.get_otp_details.return_value = \
            GetOTPDetailsDTO(
                otp=previous_otp_value
            )

        phone_number_otp_verification_interactor.verify_phone_number(
            phone_number_dto=phone_number_dto,
            phone_number_validator=phone_number_validator_mock,
            send_otp_through=send_otp_through,
            sms_sender=sms_sender_mock,
            call_service=call_service_mock
        )

        otp_blacklist_storage_mock.is_phone_number_blacklisted. \
            assert_called_once_with(
                phone_number_dto=phone_number_dto
            )
        otp_verification_storage_mock.get_otp_details.assert_called_once_with(
            phone_number_dto=phone_number_dto,
            verification_type=verification_type_mock
        )
        otp_verification_storage_mock.update_otp_details. \
            assert_called_once_with(
                phone_number_dto=phone_number_dto,
                otp=previous_otp_value,
                expiry_time_in_sec=expiry_time_in_sec,
                verification_type=verification_type_mock
            )
        if send_otp_through == SendOTPThrough.SMS:
            sms_sender_mock.send_otp.assert_called_once()
        elif send_otp_through == SendOTPThrough.CALL:
            call_service_mock.request_call.assert_called_once()

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_UPDATE_PHONE_NUMBER_WITH_OTP,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    @pytest.mark.parametrize('send_otp_through', [
        SendOTPThrough.CALL,
        SendOTPThrough.SMS
    ])
    def test_verify_phone_number_when_phone_number_is_black_listed(self,
                                    setup,
                                    verification_type_mock: VerificationType,
                                    send_otp_through: SendOTPThrough):
        phone_number_dto,  otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, phone_number_validator_mock = setup

        phone_number_otp_verification_interactor = PhoneNumberOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        otp_blacklist_storage_mock.is_phone_number_blacklisted.return_value \
            = True
        otp_verification_storage_mock.is_phone_number_whitelisted.return_value = False

        with pytest.raises(PhoneNumberIsBlackListedException) as e:
            phone_number_otp_verification_interactor.verify_phone_number(
                phone_number_dto=phone_number_dto,
                phone_number_validator=phone_number_validator_mock,
                send_otp_through=send_otp_through,
                sms_sender=sms_sender_mock,
                call_service=call_service_mock
            )

        otp_blacklist_storage_mock.is_phone_number_blacklisted. \
            assert_called_once_with(
                phone_number_dto=phone_number_dto
            )

        assert ExceptionMessage.GIVEN_PHONE_NUMBER_IS_BLACK_LISTED \
               in str(e.value)

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_UPDATE_PHONE_NUMBER_WITH_OTP,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    @pytest.mark.parametrize('send_otp_through', [
        SendOTPThrough.CALL,
        SendOTPThrough.SMS
    ])
    def test_verify_phone_number_when_phone_number_is_white_listed(self,
                                       setup,
                                       verification_type_mock: VerificationType,
                                       send_otp_through: SendOTPThrough):
        phone_number_dto, otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, phone_number_validator_mock = setup
        otp = "123456"
        expiry_time_in_sec = OTP_EXPIRY_TIME_IN_SEC
        otp_blacklist_storage_mock.is_phone_number_blacklisted. \
            return_value = False
        otp_verification_storage_mock.is_phone_number_whitelisted.\
            return_value = True
        otp_verification_storage_mock.get_configured_otp_for_phone_number.\
            return_value = GetOTPDetailsDTO(
                    otp=otp
            )
        otp_status = OTPStatus.NOT_REQUESTED
        otp_verification_storage_mock.get_otp_status.return_value = otp_status
        phone_number_otp_verification_interactor = PhoneNumberOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        phone_number_otp_verification_interactor.verify_phone_number(
            phone_number_dto=phone_number_dto,
            phone_number_validator=phone_number_validator_mock,
            send_otp_through=send_otp_through,
            sms_sender=sms_sender_mock,
            call_service=call_service_mock

        )
        otp_verification_storage_mock.is_phone_number_whitelisted. \
            assert_called_once_with(
                phone_number_dto=phone_number_dto
        )

        otp_verification_storage_mock.get_configured_otp_for_phone_number.\
            assert_called_once_with(
                phone_number_dto=phone_number_dto
        )

        otp_verification_storage_mock.get_otp_status. \
            assert_called_once_with(
                phone_number_dto=phone_number_dto,
                verification_type=verification_type_mock
            )

        otp_verification_storage_mock.create_otp_verification. \
            assert_called_once_with(
                phone_number_dto=phone_number_dto,
                verification_type=verification_type_mock,
                otp=otp,
                expiry_time_in_sec=expiry_time_in_sec
            )

        if send_otp_through == SendOTPThrough.SMS:
            sms_sender_mock.send_otp.assert_called_once_with(
                country_code=phone_number_dto.country_code,
                phone_number=phone_number_dto.phone_number,
                otp=otp
            )
        elif send_otp_through == SendOTPThrough.CALL:
            call_service_mock.request_call.assert_called_once_with(
                country_code=phone_number_dto.country_code,
                phone_number=phone_number_dto.phone_number,
                otp=otp
            )

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_UPDATE_PHONE_NUMBER_WITH_OTP,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    @pytest.mark.parametrize('send_otp_through', [
        SendOTPThrough.CALL,
        SendOTPThrough.SMS
    ])
    def test_verify_phone_number_when_prev_otp_is_expired(self, setup,
                                   verification_type_mock: VerificationType,
                                   send_otp_through: SendOTPThrough):

        otp_status = OTPStatus.EXPIRED
        previous_otp_value = "123456"
        expiry_time_in_sec = OTP_EXPIRY_TIME_IN_SEC

        phone_number_dto,  otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, phone_number_validator_mock = setup

        phone_number_otp_verification_interactor = PhoneNumberOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        otp_blacklist_storage_mock.is_phone_number_blacklisted.return_value \
            = False
        otp_verification_storage_mock.is_phone_number_whitelisted.return_value = False
        otp_verification_storage_mock.get_otp_status.return_value = otp_status

        phone_number_otp_verification_interactor.verify_phone_number(
            phone_number_dto=phone_number_dto,
            phone_number_validator=phone_number_validator_mock,
            send_otp_through=send_otp_through,
            sms_sender=sms_sender_mock,
            call_service=call_service_mock
        )

        otp_blacklist_storage_mock.is_phone_number_blacklisted. \
            assert_called_once_with(
                phone_number_dto=phone_number_dto
            )
        otp_verification_storage_mock.update_otp_details.assert_called_once_with(
                phone_number_dto=phone_number_dto,
                otp=previous_otp_value,
                expiry_time_in_sec=expiry_time_in_sec,
                verification_type=verification_type_mock
        )
        if send_otp_through == SendOTPThrough.SMS:
            sms_sender_mock.send_otp.assert_called_once()
        elif send_otp_through == SendOTPThrough.CALL:
            call_service_mock.request_call.assert_called_once()

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_UPDATE_PHONE_NUMBER_WITH_OTP,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    @pytest.mark.parametrize('send_otp_through', [
        SendOTPThrough.CALL,
        SendOTPThrough.SMS
    ])
    def test_verify_phone_number_when_phone_number_is_invalid(self, setup,
                            verification_type_mock: VerificationType,
                            send_otp_through: SendOTPThrough):
        phone_number_dto,  otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, phone_number_validator_mock = setup

        phone_number_otp_verification_interactor = PhoneNumberOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        phone_number_validator_mock.validate.side_effect = \
            InvalidPhoneNumberException(
                ExceptionMessage.ENTER_A_VALID_PHONE_NUMBER)
        otp_blacklist_storage_mock.is_phone_number_blacklisted.return_value \
            = False
        otp_verification_storage_mock.is_phone_number_whitelisted.return_value = False

        with pytest.raises(InvalidPhoneNumberException) as e:
            phone_number_otp_verification_interactor.verify_phone_number(
                phone_number_dto=phone_number_dto,
                phone_number_validator=phone_number_validator_mock,
                send_otp_through=send_otp_through,
                sms_sender=sms_sender_mock,
                call_service=call_service_mock
            )

        assert ExceptionMessage.ENTER_A_VALID_PHONE_NUMBER in str(e.value)