import typing
from dataclasses import dataclass
from typing import List

from ib_users.constants.otp_verification_constants import SendOTPThrough
from ib_users.constants.user_profile.enums import Gender, Language
from ib_users.exceptions.registration_exceptions import \
    AccountWithThisEmailAlreadyExistsException, \
    AccountWithThisPhoneNumberAlreadyExistsException
from ib_users.interactors.DTOs.common_dtos import PhoneNumberDTO
from ib_users.interactors.exceptions.user_credentials_exceptions import AccountWithEmailDoesntExistException
from ib_users.interactors.storages.user_accounts_storage import \
    UserAccountsStorage, UserAccountDTO
from ib_users.interactors.third_party.otp_provider import OTPProvider
from ib_users.interactors.third_party.otp_service import OTPService
from ib_users.interactors.third_party.social_account import SocialAccount
from ib_users.validators.base_validator import CustomException


@dataclass
class UserProfileDTO:
    name: str = None
    gender: Gender = None
    dob: str = None
    profile_pic_url: str = None
    phone_number: str = None
    country_code: str = None
    email: str = None
    language_preference: Language = None
    is_phone_number_verified: bool = None
    is_email_verified: bool = None
    iso_country_code: typing.Optional[str] = None
    last_name: typing.Optional[str] = None
    cover_page_url: typing.Optional[str] = None


@dataclass
class CreateUserProfileDTO:
    name: str = None
    gender: Gender = None
    dob: str = None
    profile_pic_url: str = None
    phone_number: str = None
    country_code: str = None
    email: str = None
    language_preference: Language = None
    is_phone_number_verified: bool = None
    is_email_verified: bool = None
    iso_country_code: typing.Optional[str] = None
    last_name: typing.Optional[str] = None
    cover_page_url: typing.Optional[str] = None


@dataclass
class GetUserProfileDTO:
    user_id: str
    name: str
    gender: Gender = None
    dob: str = None
    profile_pic_url: str = None
    phone_number: str = None
    is_phone_number_verified: bool = None
    country_code: str = None
    email: str = None
    is_email_verified: bool = None
    is_active: bool = None
    language_preference: Language = None
    iso_country_code: typing.Optional[str] = None
    last_name: typing.Optional[str] = None
    cover_page_url: typing.Optional[str] = None


class UserProfileInteractor:
    def __init__(self, storage, presenter):
        self.storage = storage
        self.presenter = presenter

    def _check_and_throw_error_for_invalid_data_in_update_profile(
            self,
            user_id: str,
            update_profile_data: UserProfileDTO,
            accounts_storage: UserAccountsStorage):
        phone_number, country_code, gender, language, email, dob = \
            update_profile_data.phone_number, update_profile_data.country_code, \
            update_profile_data.gender, \
            update_profile_data.language_preference, \
            update_profile_data.email, update_profile_data.dob

        self._check_and_throw_error_for_invalid_user_id(user_id=user_id)
        self._check_and_throw_error_for_user_does_not_exist(user_id=user_id)
        self._check_and_throw_error_for_invalid_dob(dob=dob)
        self._check_and_throw_error_for_invalid_email(email=email)
        self._check_and_throw_error_for_email_used_for_another_account(
            email=email, accounts_storage=accounts_storage, user_id=user_id)
        self._check_and_throw_error_for_invalid_gender(gender=gender)
        self._check_and_throw_error_for_invalid_language(language=language)
        self._check_and_throw_error_for_invalid_country_code_or_phone_number(
            country_code=country_code, phone_number=phone_number
        )
        self._check_and_throw_error_for_used_phone_number(
            country_code=country_code,
            phone_number=phone_number,
            accounts_storage=accounts_storage)

    def _check_and_throw_error_for_invalid_data_in_create_profile(
            self,
            create_profile_data: CreateUserProfileDTO,
            user_details: UserAccountDTO,
            accounts_storage: UserAccountsStorage):
        phone_number, country_code, gender, language, email, dob = \
            create_profile_data.phone_number, create_profile_data.country_code, \
            create_profile_data.gender, \
            create_profile_data.language_preference, \
            create_profile_data.email, create_profile_data.dob

        user_id = str(user_details.user_id)
        self._check_and_throw_error_for_invalid_user_id(user_id=user_id)
        self._check_and_throw_error_for_user_exists(user_id=user_id)
        self._check_and_throw_error_for_invalid_dob(dob=dob)
        self._check_and_throw_error_for_invalid_email(email=email)
        self._check_and_throw_error_for_email_used_for_another_account(
            email=email, accounts_storage=accounts_storage, user_id=user_id)
        self._check_and_throw_error_for_invalid_country_code_or_phone_number(
            country_code=country_code, phone_number=phone_number
        )
        self._check_and_throw_error_for_invalid_gender(gender=gender)
        self._check_and_throw_error_for_invalid_language(language=language)

        self._check_and_throw_for_email_mismatch(
            email=email, account_email=user_details.email)
        self._check_and_throw_for_phone_number_mismatch(
            country_code=country_code, phone_number=phone_number,
            account_phone_number=user_details.phone_number,
            account_country_code=user_details.country_code)

    @staticmethod
    def _check_and_throw_error_for_email_used_for_another_account(
            email, accounts_storage: UserAccountsStorage, user_id):
        if not email:
            return

        try:
            existing_user_id = accounts_storage.get_existing_user_id_given_email(email)
            if existing_user_id != str(user_id):
                from .exceptions.user_profile import \
                    EmailAlreadyLinkedException
                from ib_users.constants.custom_exception_messages import \
                    EMAIL_ALREADY_IN_USE
                raise EmailAlreadyLinkedException(EMAIL_ALREADY_IN_USE.message,
                                                  EMAIL_ALREADY_IN_USE.code)
        except AccountWithEmailDoesntExistException:
            pass

    @staticmethod
    def _check_and_throw_for_email_mismatch(
            email: str, account_email):
        if account_email:
            if email != account_email:
                from ib_users.validators.email_validator import EmailValidator
                from ib_users.exceptions.invalid_email_exception import \
                    InvalidEmailException
                from ib_users.constants.custom_exception_messages import \
                    INVALID_EMAIL
                from ib_users.validators.base_validator import CustomException

                raise InvalidEmailException(
                    INVALID_EMAIL.message, INVALID_EMAIL.code)

    @staticmethod
    def _check_and_throw_for_phone_number_mismatch(
            country_code: str, phone_number: str,
            account_phone_number, account_country_code):

        if account_phone_number and account_country_code:
            if account_country_code + account_phone_number != \
                    country_code + phone_number:
                from ib_users.exceptions.invalid_phone_number_exception import \
                    InvalidPhoneNumberException
                from ib_users.constants.custom_exception_messages import \
                    INVALID_PHONE_NUMBER
                raise InvalidPhoneNumberException(
                    INVALID_PHONE_NUMBER.message, INVALID_PHONE_NUMBER.code)

    @staticmethod
    def _check_and_throw_error_for_invalid_user_id(user_id: str):
        if user_id is None:
            from ib_users.interactors.exceptions.user_profile import \
                InvalidUserException
            from ib_users.constants.user_profile.error_messages import \
                EMPTY_USER_ID
            from ib_users.constants.user_profile.error_types import \
                EMPTY_USER_ID_ERROR_TYPE
            raise InvalidUserException(message=EMPTY_USER_ID,
                                       exception_type=EMPTY_USER_ID_ERROR_TYPE)

    def _check_and_throw_error_for_user_exists(self, user_id):
        if self.storage.does_user_exists(user_id):
            from ib_users.interactors.exceptions.user_profile import \
                InvalidUserException
            from ib_users.constants.user_profile.error_messages import \
                INVALID_USER_ID
            from ib_users.constants.user_profile.error_types import \
                INVALID_USER_ID_ERROR_TYPE
            from ib_users.constants.user_profile.error_messages import \
                USER_ALREADY_HAS_PROFILE
            from ib_users.constants.user_profile.error_types import \
                USER_ALREADY_HAS_PROFILE_TYPE

            raise InvalidUserException(message=USER_ALREADY_HAS_PROFILE,
                                       exception_type=USER_ALREADY_HAS_PROFILE_TYPE)

    def _check_and_throw_error_for_user_does_not_exist(self, user_id):
        if not self.storage.does_user_exists(user_id):
            from ib_users.interactors.exceptions.user_profile import \
                InvalidUserException
            from ib_users.constants.user_profile.error_messages import \
                INVALID_USER_ID
            from ib_users.constants.user_profile.error_types import \
                INVALID_USER_ID_ERROR_TYPE
            raise InvalidUserException(message=INVALID_USER_ID,
                                       exception_type=INVALID_USER_ID_ERROR_TYPE)

    def _check_and_throw_error_for_users_does_not_exist_bulk(self, user_ids):
        if self.storage.is_any_user_id_invalid(user_ids):
            from ib_users.interactors.exceptions.user_profile import \
                InvalidUserException
            from ib_users.constants.user_profile.error_messages import \
                INVALID_USER_ID
            from ib_users.constants.user_profile.error_types import \
                INVALID_USER_ID_ERROR_TYPE
            raise InvalidUserException(message=INVALID_USER_ID,
                                       exception_type=INVALID_USER_ID_ERROR_TYPE)

    @staticmethod
    def _check_and_throw_error_for_invalid_dob(dob: str):
        if dob is not None:
            from ib_users.validators.dob_validator import DOBValidator
            DOBValidator.validate(dob)

    @staticmethod
    def _check_and_throw_error_for_invalid_email(email: str):
        if not email:
            return

        from ib_users.validators.email_validator import EmailValidator
        from ib_users.exceptions.invalid_email_exception import \
            InvalidEmailException
        from ib_users.constants.custom_exception_messages import INVALID_EMAIL
        from ib_users.validators.base_validator import CustomException
        try:
            EmailValidator.validate(email)
        except CustomException:
            raise InvalidEmailException(INVALID_EMAIL.message,
                                        INVALID_EMAIL.code)

    def _check_email_is_registered(self, email: str,
                                   accounts_storage: UserAccountsStorage):
        try:
            accounts_storage.check_user_exists_with_email(email)
            return False
        except AccountWithThisEmailAlreadyExistsException:
            return True

    def _check_and_throw_error_for_used_email(self, email: str,
                                              accounts_storage: UserAccountsStorage):
        if not email:
            return
        if self._check_email_is_registered(email, accounts_storage):
            from .exceptions.user_profile import \
                EmailAlreadyLinkedException
            from ib_users.constants.custom_exception_messages import \
                EMAIL_ALREADY_IN_USE
            raise EmailAlreadyLinkedException(EMAIL_ALREADY_IN_USE.message,
                                              EMAIL_ALREADY_IN_USE.code)

    @staticmethod
    def _check_and_throw_error_for_invalid_gender(gender: Gender):
        from ib_users.validators.gender_validator import \
            GenderValidator
        if gender is not None:
            GenderValidator.validate(gender)

    @staticmethod
    def _check_and_throw_error_for_invalid_language(language: Language):
        from ib_users.validators.language_validator import \
            LanguageValidator
        if language is not None:
            LanguageValidator.validate(language)

    @staticmethod
    def _check_and_throw_error_for_invalid_country_code_or_phone_number(
            country_code: str, phone_number: str):
        if ((phone_number is None and country_code is not None) or
                (phone_number is not None and country_code is None)):
            from ib_users.interactors.exceptions.user_profile import \
                PhoneNumberOrCountryCodeInvalidException
            from ib_users.constants.user_profile.error_messages import \
                BOTH_PHONE_NUMBER_AND_COUNTRY_CODE_CAN_BE_EITHER_NULL_OR_NOT_NULL
            from ib_users.constants.user_profile.error_types import \
                BOTH_PHONE_NUMBER_AND_COUNTRY_CODE_CAN_BE_EITHER_NULL_OR_NOT_NULL_ERROR_TYPE
            raise PhoneNumberOrCountryCodeInvalidException(
                message=BOTH_PHONE_NUMBER_AND_COUNTRY_CODE_CAN_BE_EITHER_NULL_OR_NOT_NULL,
                exception_type=BOTH_PHONE_NUMBER_AND_COUNTRY_CODE_CAN_BE_EITHER_NULL_OR_NOT_NULL_ERROR_TYPE)

        if phone_number is not None and country_code is not None:
            from ib_users.interactors.storages.user_accounts_storage import \
                PhoneNumberDTO
            phone_number_dto = PhoneNumberDTO(country_code=country_code,
                                              phone_number=phone_number)
            from ib_users.validators.phone_number_validator_impl import \
                PhoneNumberValidatorImpl
            phone_number_validator = PhoneNumberValidatorImpl()
            phone_number_validator.validate(phone_number_dto)

    def _check_phone_number_is_registered(self, phone_number,
                                          accounts_storage: UserAccountsStorage):
        try:
            accounts_storage.check_user_exists_with_phone_number(
                phone_number_dto=phone_number)
            return False
        except AccountWithThisPhoneNumberAlreadyExistsException:
            return True

    def _check_and_throw_error_for_used_phone_number(self, phone_number: str,
                                                     country_code: str,
                                                     accounts_storage: UserAccountsStorage):
        if not (phone_number and country_code):
            return

        if self._check_phone_number_is_registered(
                phone_number=PhoneNumberDTO(country_code, phone_number),
                accounts_storage=accounts_storage):
            from ib_users.constants.custom_exception_messages import \
                PHONE_NUMBER_ALREADY_IN_USE
            from ib_users.exceptions.invalid_phone_number_exception import \
                InvalidPhoneNumberException
            raise InvalidPhoneNumberException(
                PHONE_NUMBER_ALREADY_IN_USE.message,
                PHONE_NUMBER_ALREADY_IN_USE.code)

    def get_user_profile(self, user_id: str):
        self._check_and_throw_error_for_invalid_user_id(user_id=user_id)
        self._check_and_throw_error_for_user_does_not_exist(user_id=user_id)
        user_profile = self.storage.get_user_profile(user_id=user_id)
        return self.presenter.get_user_profile(user_profile)

    def get_user_profiles(self, user_ids: List[str]):
        for user_id in user_ids:
            self._check_and_throw_error_for_invalid_user_id(user_id=user_id)

        self._check_and_throw_error_for_users_does_not_exist_bulk(
            user_ids=user_ids
        )
        user_profiles = self.storage.get_user_profiles(user_ids=user_ids)
        return self.presenter.get_user_profiles(user_profiles)

    def create_user_profile(self, user_id: str,
                            create_profile_data: CreateUserProfileDTO,
                            accounts_storage: UserAccountsStorage):
        user_details = accounts_storage.get_user_account_details(user_id)

        self._check_and_throw_error_for_invalid_data_in_create_profile(
            user_details=user_details,
            create_profile_data=create_profile_data,
            accounts_storage=accounts_storage
        )

        create_profile_data = self._update_verification_status_for_create_profile(
            create_profile_data, user_details)
        self.storage.create_user_profile(
            create_profile_data, account_id=user_id)
        return

    def create_user_profile_from_social_account(
            self, user_id: str, social_sdk: SocialAccount, accounts_storage: UserAccountsStorage, **kwargs):
        user_name = social_sdk.get_user_name_from_social_account(**kwargs)
        email = social_sdk.get_email_from_social_account(**kwargs)
        create_profile_data = CreateUserProfileDTO(
            name=user_name,
            email=email,
            is_email_verified=True
        )
        self.create_user_profile(
            user_id=user_id,
            create_profile_data=create_profile_data,
            accounts_storage=accounts_storage)
        accounts_storage.update_email(user_id=user_id, email=email)

    def update_user_profile(self, user_id: str,
                            update_profile_data: UserProfileDTO,
                            accounts_storage: UserAccountsStorage):

        self._check_and_throw_error_for_invalid_data_in_update_profile(
            user_id=user_id,
            update_profile_data=update_profile_data,
            accounts_storage=accounts_storage)

        user_details = accounts_storage.get_user_account_details(user_id)

        previous_phone_number = ""
        new_phone_number = ""
        if user_details.country_code and user_details.phone_number:
            previous_phone_number = user_details.country_code + user_details.phone_number

        if update_profile_data.country_code and update_profile_data.phone_number:
            new_phone_number = update_profile_data.country_code + update_profile_data.phone_number

        if (previous_phone_number != new_phone_number) and new_phone_number != "":
            update_profile_data.is_phone_number_verified = False
            accounts_storage.update_user_phone_number(
                user_id, phone_number=None, country_code=None)

        if user_details.email != update_profile_data.email and update_profile_data.email:
            update_profile_data.is_email_verified = False
            accounts_storage.update_email(user_id=user_id, email=None)

        self.storage. \
            update_user_profile(user_id=user_id,
                                update_profile_data=update_profile_data)

        user_profile = self.storage.get_user_profile(user_id=user_id)
        return self.presenter.update_user_profile(user_profile=user_profile)

    def verify_user_phone_number(self, accounts_storage: UserAccountsStorage,
                                 user_id: str, otp_service,
                                 send_otp_through: SendOTPThrough):
        from django.conf import settings

        from .exceptions.user_profile import \
            CountryCodeAndPhoneNumberDoesNotExistException, \
            CountryCodeDoesNotExistException, PhoneNumberDoesNotExistException, \
            PhoneNumberAlreadyLinkedException

        self._check_and_throw_error_for_user_does_not_exist(user_id)
        # TODO: Change to call OTP module to send OTP to user
        country_code, phone_number = self.storage.get_user_country_code_and_phone_number(
            user_id)
        if country_code is None and phone_number is None:
            raise (CountryCodeAndPhoneNumberDoesNotExistException())
        if country_code is None:
            raise (CountryCodeDoesNotExistException())
        if phone_number is None:
            raise (PhoneNumberDoesNotExistException())

        #  TODO: Need to call Accounts interactor with accounts storage after implementation
        phone_number_dto = PhoneNumberDTO(country_code=country_code,
                                          phone_number=phone_number)

        try:
            phone_user_id = accounts_storage.get_user_id_given_phone_number(
                phone_number_dto=phone_number_dto
            )
            is_phone_number_already_linked = user_id != phone_user_id
        except CustomException:
            is_phone_number_already_linked = False

        if is_phone_number_already_linked:
            raise (PhoneNumberAlreadyLinkedException())
        from ib_users.constants.otp_constants import OTPMessageFormatConstants

        sms_template = OTPMessageFormatConstants.FORMAT_TO_VERIFY_PHONE_NUMBER
        call_template = settings.VERIFY_PHONE_NUMBER_OTP_CALL_TEMPLATE
        if self._is_twilio_message_service_used_to_send_sms(
                country_code=phone_number_dto.country_code):
            sms_template = accounts_storage.get_message_template_string(
                message_template_id=settings.TWILIO_MESSAGE_TEMPLATE_ID_TO_VERIFY_PHONE_NUMBER)

        otp_service.send_otp_to_user_phone_number(
            phone_number=phone_number_dto,
            template=sms_template,
            call_template=call_template,
            send_otp_through=send_otp_through)

    def verify_and_link_user_phone_number_to_account(
            self, otp_service, accounts_storage: UserAccountsStorage,
            user_id: str, otp: str):

        self._check_and_throw_error_for_user_does_not_exist(user_id=user_id)

        (country_code, phone_number) = \
            self.storage.get_user_country_code_and_phone_number(
                user_id=user_id)
        phone_number_dto = PhoneNumberDTO(country_code=country_code,
                                          phone_number=phone_number)

        otp_service.validate_otp_send_to_phone_number(
            phone_number_dto=phone_number_dto, otp=otp)
        self.link_user_phone_number_to_account(
            user_id=user_id,
            phone_number_dto=phone_number_dto,
            accounts_storage=accounts_storage
        )

    def link_user_phone_number_to_account(
            self, user_id: str, accounts_storage: UserAccountsStorage,
            phone_number_dto: PhoneNumberDTO
    ):
        accounts_storage.link_phone_number_to_user(
            user_id, phone_number_dto=phone_number_dto)
        self.storage.update_user_phone_number_verified(user_id=user_id)

    def generate_time_based_code_for_user(self,
                                          otp_provider: OTPProvider,
                                          user_id: str,
                                          configured_time_in_seconds: int):

        self._check_and_throw_error_for_user_does_not_exist(user_id)
        import base64
        user_secret = base64.b32encode(bytearray(str(user_id), 'utf-8'))

        otp = otp_provider.generate_time_based_code_for_user(
            user_secret, configured_time_in_seconds)
        return self.presenter.generate_user_code(user_code=otp)

    def verify_user_email(self, accounts_storage: UserAccountsStorage,
                          user_id: str, otp_service: OTPService):
        self._check_and_throw_error_for_user_does_not_exist(user_id)
        user_email = self.storage.get_user_email(user_id=user_id)

        if user_email is None:
            from .exceptions.user_profile import EmailDoesNotExistException
            raise (EmailDoesNotExistException())

        try:
            user_id_for_given_email = accounts_storage.get_user_id_given_email(
                email=user_email)
            is_email_already_liked = user_id != user_id_for_given_email
        except CustomException:
            is_email_already_liked = False

        if is_email_already_liked:
            from ib_users.interactors.exceptions.user_profile import \
                EmailAlreadyLinkedException
            raise EmailAlreadyLinkedException()

        from ib_users.constants.otp_constants import OTPMessageFormatConstants
        otp_service.send_otp_to_user_email(
            user_email,
            template=OTPMessageFormatConstants.FORMAT_TO_VERIFY_EMAIL,
            subject=OTPMessageFormatConstants.OTP_SUBJECT_TO_VERIFY_EMAIL)

    def verify_and_link_user_email_to_account(self,
                                              accounts_storage: UserAccountsStorage,
                                              user_id: str,
                                              otp_service,
                                              otp: str):
        self._check_and_throw_error_for_user_does_not_exist(user_id=user_id)
        email = self.storage.get_user_email(user_id=user_id)

        try:
            user_id_for_given_email = accounts_storage.get_user_id_given_email(
                email=email)
            is_email_already_liked = user_id != user_id_for_given_email
        except CustomException:
            is_email_already_liked = False

        if is_email_already_liked:
            from ib_users.interactors.exceptions.user_profile import \
                EmailAlreadyLinkedException
            raise EmailAlreadyLinkedException()

        otp_service.validate_otp_send_to_email(email=email, otp=otp)
        accounts_storage.link_email_to_user(
            user_id=user_id,
            email=email
        )
        self.storage.update_user_email_verified(user_id=user_id)

    def link_user_email_to_account(self, accounts_storage: UserAccountsStorage, user_id):
        self._check_and_throw_error_for_user_does_not_exist(user_id=user_id)
        email = self.storage.get_user_email(user_id=user_id)
        self._check_and_throw_error_for_used_email(
            email=email, accounts_storage=accounts_storage)
        accounts_storage.link_email_to_user(
            user_id=user_id,
            email=email
        )
        self.storage.update_user_email_verified(user_id=user_id)

    def _update_verification_status_for_create_profile(
            self, create_profile_data, user_details):

        if user_details.phone_number:
            create_profile_data.is_phone_number_verified = True
        if user_details.email:
            create_profile_data.is_email_verified = True
        return create_profile_data

    @staticmethod
    def _is_twilio_message_service_used_to_send_sms(country_code: str) -> bool:
        from django.conf import settings
        from ib_users.constants.sms_constants import INDIA_COUNTRY_CODE

        need_to_use_twilio = False
        if country_code != INDIA_COUNTRY_CODE and settings.USE_TWILIO_FOR_INTERNATIONAL_NUMBERS:
            need_to_use_twilio = True

        return need_to_use_twilio
